---
title: "<Insert title>"
output: 
  html_document: 
    keep_md: yes
    number_sections: yes
    toc: yes
---

```{r echo=FALSE}
knitr::opts_chunk$set(cache  = TRUE)
knitr::opts_knit$set(verbose = TRUE)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r library_information_1}
LIBRARY      <- "<Insert library ID>"  # For example, the sequencing run ID.
ZENBU_COLLAB <- "<Insert Zenbu collaboration ID>"
WORKFLOW     <- "<Insert workflow ID>" # For example "OP-WORKFLOW-CAGEscan-short-reads-v2.0"
MOIRAI_STAMP <- "<Insert Moirai run stamp>" # For example "20150803121351"
MOIRAI_PROJ  <- "<Insert Moirai user name>" # For example "Charles"
MOIRAI_USER  <- "<Insert Moirai user name>" # For example "nano-fluidigm"
ASSEMBLY     <- "<Insert name of genome assembly>" # For example "hg38"

# The following is still hardcoded...
# See https://gist.github.com/charles-plessy/9dbc8bc98fb773bf71b6 for hints

GROUP_SHARED <- "/osc-fs_home/scratch/gmtu"
GENE_SYMBOLS <- paste0(GROUP_SHARED, "/annotation/homo_sapiens/gencode-23/gencode.v23.annotation.genes.bed")
ANNOTATION   <- paste0(GROUP_SHARED, "/annotation/homo_sapiens/gencode-23/gencode.v23.annotation.bed")

# In case of a pair of Fludigm C1 CAGE runs, uncomment the lines below and fill
# insert missing information.  Otherwise, delete or leave as it is.
#RunA         <- "<Insert ID of Run A>"
#RunB         <- "<Insert ID of Run B>"
#ctrls        <- list( RunA=list(posi="<Insert well ID>", nega="<Insert well ID>")
#                    , RunB=list(posi="<Insert well ID>", nega="<Insert well ID>"))
```

<!-- Example title: MiSeq run `r LIBRARY` -->

<Insert title>
==============

 - C1 runs `r RunA` and `r RunB`.
 - Sequenced on MiSeq (`r LIBRARY`)
 
<!-- The lines about cellomics and controls below can be deleted if not using
     C1 CAGE -->

- cellomics IDs:
   - `r RunA`: <Insert short description of Run A>
   - `r RunB`: <Insert short description of Run B>

 - Positive control (200 cells): `r ctrls$RunA$posi`, `r ctrls$RunB$posi`.
 - Negative control: `r ctrls$RunA$nega`, `r ctrls$RunB$nega`.
 
Jump directly to the [Analysis](#analysis) section if you are not interested in the details of the data processing.


Data Processing
===============

Link files from MOIRAI.
-----------------------

```{r library_information_2}
BASEDIR      <- "/osc-fs_home/scratch/moirai"
MOIRAI_RUN   <- paste(LIBRARY, WORKFLOW, MOIRAI_STAMP, sep=".")
MOIRAI_BASE  <- paste(BASEDIR, MOIRAI_USER, "project", MOIRAI_PROJ, MOIRAI_RUN, sep="/")
MOIRAI_ID    <- paste(LIBRARY, WORKFLOW, MOIRAI_STAMP, sep=".")
MOIRAI_FRAGS <- paste0(MOIRAI_BASE, "/CAGEscan_fragments")
MOIRAI_BAM   <- paste0(MOIRAI_BASE, "/genome_mapped")
MOIRAI_URL   <- paste0("http://moirai.gsc.riken.jp/", MOIRAI_BASE, "/", MOIRAI_RUN, ".html")

smallCAGEqc::exportInEnv("LIBRARY", "MOIRAI_BASE", "GENE_SYMBOLS", "ANNOTATION")
```

 Intranet link: [`r MOIRAI_RUN`](`r MOIRAI_URL`)

Create a symbolic link from Moirai results to the working directory.

```{r create_link, engine="bash"}
[ -L $LIBRARY.l1.osc.gz ] ||
  ln --symbolic $MOIRAI_BASE/$LIBRARY.l1.osc.gz
```

Annotation and gene symbols.
----------------------------

```{r annotate_bed, engine="bash"}
function osc2bed {
  zcat $1 |
    grep -v \# |
    sed 1d |
    awk '{OFS="\t"}{print $2, $3, $4, "l1", "1000", $5}'
}

function bed2annot {
  bedtools intersect -a $1 -b $ANNOTATION -s -loj |
    awk '{OFS="\t"}{print $1":"$2"-"$3$6,$10}' | 
    bedtools groupby -g 1 -c 2 -o collapse
}

function bed2symbols {
  bedtools intersect -a $1 -b $GENE_SYMBOLS -s -loj |
    awk '{OFS="\t"}{print $1":"$2"-"$3$6,$10}' | 
    bedtools groupby -g 1 -c 2 -o distinct
}

osc2bed $LIBRARY.l1.osc.gz | tee $LIBRARY.l1.bed | bed2annot - > $LIBRARY.l1.annot
bed2symbols $LIBRARY.l1.bed > $LIBRARY.l1.genes
```

Data load and QC in R.
======================

Moirai metadata
---------------

```{r load_libs_and_moirai, message=F}
library(oscR)
library(smallCAGEqc)
stopifnot(
    packageVersion("oscR") >= "0.2.0"
  , packageVersion("smallCAGEqc") > "0.11.2"
)
library(data.table)
library(magrittr)
library(reshape)
library(ggplot2)
library(vegan)
library(plyr)

PROCESSED_DATA <- MOIRAI_BASE

libs <- loadMoiraiStats() #  %>% llPostProcess('nano-fluidigm')
```

Transcript counts (properly paired)
-----------------------------------

Note that `fread` needs to temporarly save an uncompressed copy of the file
that is being read.  If there is not enough space in the temporary directory
(often `\tmp`),  either uncompress the file first, or point to a larger
directory to contain the temporary files (for example, run `R` with `TMPDIR=.
R`).

Note that _data.tables_ seem to be saved as simple _data frames_ when
closing a session.  After restoring a workspace, one needs to re-convert with the `data.table` command.

```{r load_osc_data}
l1 <- fread.osc(paste0(LIBRARY, ".l1.osc.gz"), dropIdCoords=TRUE)

setnames(l1, colnames(l1) %>% sub('raw.', '', .) %>% sub('.None', '', .) %>% sub('RunA',RunA,.) %>% sub('RunB',RunB,.))

# Be sure that the "libs" and "l1" tables have matching names.
stopifnot(all(colnames(l1) == rownames(libs)))
```

Annotation
----------

```{r annotate_l1}
annot.l1 <- read.table(paste(LIBRARY,'l1','annot',sep='.'), head=F, col.names=c('id', 'feature'), row.names=1)
annot.l1 <- hierarchAnnot(annot.l1)

libs <- cbind(libs, t(rowsum(l1,  annot.l1[,'class']))[rownames(libs),])
```

Gene count
----------

```{r genesymbols_l1}
genesymbols <- read.table(paste(LIBRARY,'l1','genes',sep='.'), col.names=c("cluster","symbol"), stringsAsFactors=FALSE)
rownames(genesymbols) <- genesymbols$cluster

genes <- rowsum(l1, genesymbols$symbol)

libs$genes       <- colSums(genes > 0)
libs$geneSymbols <- countSymbols(genes) # Not the same!
```


Raw reads per molecule (BED12 data)
-----------------------------------

```{r load_fragments}
bed <- loadBED12( libs$samplename %>%
             sub(RunA, "RunA", .) %>%
             sub(RunB, "RunB", .) %>%
             paste0(MOIRAI_FRAGS, "/", ., ".bed"))
```

Cell pictures
-------------

```{r load_fluo_data}
read.fluo <- function(RUN) read.delim( paste0("../imageJ/", RUN, ".txt")
                                     , row.names="cell_id"
                                     , stringsAsFactors = FALSE)
fluo <- rbind(read.fluo(RunA), read.fluo(RunB))
libs <- cbind(libs, subset(fluo,,c("mean_ch2", "bg_mean_ch2", "mean_ch3", "bg_mean_ch3", "Error", "Comment")))
libs$Error <- factor( libs$Error
                    , levels=c("0-No Error", "1-No cell", "2-Debris", "3-OutOfFocus", "4-MultipleCells", "5-Control", "6-Dead"))
```

A hardocoded treshold of 2.5 is used to identify dead cells.  The histogram
below is to check if this value makes sense in this dataset.

```{r dead-cells, dev=c('svg', 'png'), fig.height=2.5}
hist( libs$mean_ch3 - libs$bg_mean_ch3
    , br   = 100
    , main = "Current threshold for identifying dead cells"
    , xlab = "mean_ch3 - bg_mean_ch3" )
deadThresh <- 2.5
abline(v=deadThresh, col="red")

libs[libs$mean_ch3 - libs$bg_mean_ch3 > deadThresh, "Error"] <- "6-Dead"
```

Controls
--------

Some samples with errors were repalced by the positive and negative controls.

```{r flag-controls}
libs[libs$Well %in% ctrls[["RunA"]] & libs$Run == RunA, "Error"]   <- "5-Control"
libs[libs$Well %in% ctrls[["RunB"]] & libs$Run == RunB, "Error"]   <- "5-Control"
libs[libs$Well == ctrls$RunA$posi & libs$Run == RunA, "Comment"] <- "Positive control"
libs[libs$Well == ctrls$RunB$posi & libs$Run == RunB, "Comment"] <- "Positive control"
libs[libs$Well == ctrls$RunA$nega & libs$Run == RunA, "Comment"] <- "Negative control"
libs[libs$Well == ctrls$RunB$nega & libs$Run == RunB, "Comment"] <- "Negative control"
```

cDNA concentration.
-------------------

```{r cDNA_concentration, dev=c('svg', 'png'), fig.height=2.5, message=FALSE, warning=FALSE}
read.pg <- function(RUN)
  paste0("../cDNA_yields/", RUN, ".picogreen.xlsx") %>%
    fldgmPicoGreen("PN 100-6160") %>%
    extract(,"concentration")
libs$Concentration <- c(read.pg(RunA), read.pg(RunB))
fldgmConcentrationPlot(libs)
```

Combined analysis of fluorescence and cDNA concentration.
---------------------------------------------------------

### Array heatmaps.

```{r define_fldgmArrayQCplot}
fldgmArrayQCplot <- function(RUN) fldgmArrayQC(libs[libs$Run==RUN,], RUN)
```

```{r 'runA.arrayQC', dev=c('svg', 'png'), fig.height=2.5}
fldgmArrayQCplot(RunA)
```

```{r 'runB.arrayQC', dev=c('svg', 'png'), fig.height=2.5}
fldgmArrayQCplot(RunB)
```

### Live / dead stain and DNA concentration.

Both runs are plotted together; this explains why there may be two groups, when cDNA
yields differed strongly. 

```{r live-dead, dev=c('svg', 'png')}
with(libs, plotNameColor(Concentration, mean_ch2 - bg_mean_ch2, Error, Well))
with(libs, plotNameColor(Concentration, mean_ch3 - bg_mean_ch3, Error, Well))
```

Richness
--------

```{r calculate-richness}
libs$l1 <- colSums(l1 > 0)
libs$r100l1 <- rarefy(t(l1),100)
```

Analysis
========

```{r richness-concentration, dev=c('svg', 'png')}
with(libs, plotNameColor(Concentration, r100l1, Error, Well))
```

```{r richness-outliers, dev=c('svg', 'png')}
with(subset(libs, Error == "0-No Error"), plotNameColor(Concentration, r100l1, Run, Well))
```

QC barplots
-----------

```{r qc-barplots, dev=c('svg', 'png')}
plotAnnot(libs, 'qc', LIBRARY, libs$Group)
```

Annotation
----------

```{r annotation-barplots, dev=c('svg', 'png')}
plotAnnot(libs, 'counts', LIBRARY, libs$Group)
```

Correlation between runs
------------------------

```{r correlation-heatmap, dev=c('svg', 'png')}
library(dendextend)

# Filtering genes with extraction count < nb.filter.extracted
# Note that it can also remove negative controls
nb.filter.extracted <- 10000
# Possibility to color the clusters dendrogram if nb.clusters != 0
nb.clusters <- 0
# Please check that length(colors.dend) >= nb.clusters
colors.dend = c("red", "darkgreen", "darkseagreen", "blue", "green", "darkorange3", "grey40", "darkorchid4", "pink3", "turquoise4", "black")

# Implementing heatmap
filter.extracted <- libs$samplename[libs$extracted > nb.filter.extracted]
heatmap.genes <- NMF::aheatmap( cor(log(genes[-1, filter.extracted]+1))
             , annCol=list(Run=libs$Ru[filter.extracted], Group=libs$group[filter.extracted]) )
if(nb.clusters != 0) 
  {
       cor.dend <- heatmap.genes$Rowv %>%
         set("branches_k_color", value = colors.dend[1:nb.clusters], k = nb.clusters) %>%
         set("labels_colors", value = colors.dend[1:nb.clusters], k = nb.clusters) %>%
         set("labels_cex", .6) %>%
         ladderize(FALSE) # To ensure a reproducible visual order of the clusters
       heatmap.genes <- NMF::aheatmap( cor(log(genes[-1, filter.extracted]+1)),
              annCol=list(Run=libs$Run[filter.extracted], Group=libs$group[filter.extracted]),
              Rowv = cor.dend, Colv = cor.dend )
       # Displaying the dendrogram only
       (cor.dend.gg <- cor.dend %>% as.ggdend %>% ggplot(horiz = F))
  }
```

```{r correlation-heatmap-noerrors, dev=c('svg', 'png')}
# Uncomment if you have a Error column
#NMF::aheatmap( cor(genes[-1, libs$Error == "0-No Error"])
#             , annCol=list(Run=libs[libs$Error == "0-No Error", "Run"]))
```

```{r genes-dend-nb-clusters, dev=c('png','svg')}
# Creating an hclust object
genes.dend <- hclust(dist(cor(log(genes[-1, filter.extracted]+1))))
# Ordering heights
genes.dend.rev=rev(genes.dend$height)
# Plotting the curve of height of the dendrogram
plot(genes.dend.rev,
     col = c(colors.dend[1:nb.clusters], rep("black", length(genes.dend.rev)-1)),
     pch = 20, ylab = "Clusters height")
abline(v = nb.clusters+0.5, col = "grey60", lty = 2)
# Dividing into nb.clusters clusters
genes.dend.clusters <- cutree(genes.dend, nb.clusters)
```

PCA analysis
------------

### PCA on Genes

```{r genes-pca}
library(ade4)
library(adegraphics)
library(dplyr)

# Normalisation in tags per million and removing the • genes
genes.tpm <- t(TPM(genes[, filter.extracted]))[, -1]
# Setting the number of axis to keep in the PCA
nb.pcaAxis <- 3
# Running PCA
genes.pca <- dudi.pca(genes.tpm, center = T, scale = F, scannf = F, nf = nb.pcaAxis)
```

```{r genes-pca-summary, dev=c('png','svg')}
# Displaying information about the PCA
barplot(genes.pca$eig, xlab = "Eigenvalues")
summary(genes.pca)
```

```{r pca-functions}
#
# MAYBE SHOULD BE ADDED TO PACKAGE smallCAGEqc
#

# Returns TRUE if component is mostly oriented towards positive values
# otherwise returns FALSE
pcaCompOrientation <- function(compPCA){
  ifelse(abs(range(compPCA)[1]) > abs(range(compPCA)[2]), FALSE, TRUE)
}

# Display ordered genes names for a designated component
# For now works if nb.pcaAxis == 3
pcaCompGenesList <- function(PCAADE4co, comp){
  stopifnot(nb.pcaAxis == 3)
  genes.co <- PCAADE4co %>% 
    mutate(., geneNames = rownames(.)) %>% 
    select(geneNames, Comp1, Comp2, Comp3)
  ifelse(pcaCompOrientation(genes.co[comp+1]),
         genes.co %<>% setorderv(., colnames(.)[comp+1], order=-1),
         genes.co %<>% setorderv(., colnames(.)[comp+1], order=1))
  genes.co
}

# Barplots of head and tail genes for each component
HTB <- function(orderedCompPCA, comp, nbDispGenes = 25){
  par(mfrow=c(1,2))
  
  bp1h <- orderedCompPCA[,comp+1] %>% head(nbDispGenes) %>% barplot(. ,
          ylim = c(min(orderedCompPCA[,comp+1]), max(orderedCompPCA[,comp+1])),
          axes = FALSE, axisnames = FALSE, main = paste0("comp ", comp, " head"))
  text(bp1h, par("usr")[3], labels = orderedCompPCA$geneNames %>% head(nbDispGenes),
       srt = 90, adj = c(1.1,1.1), xpd = TRUE, cex=.6)
  axis(2)

  bp1t <- orderedCompPCA[,comp+1] %>% tail(nbDispGenes) %>% barplot(. ,
          ylim = c(min(orderedCompPCA[,comp+1]), max(orderedCompPCA[,comp+1])),
          axes = FALSE, axisnames = FALSE, main = paste0("comp ", comp, " tail"))
  text(bp1t, par("usr")[3], labels = orderedCompPCA$geneNames %>% tail(nbDispGenes),
       srt = 90, adj = c(1.1,1.1), xpd = TRUE, cex=.6)
  axis(4)
  
  par(mfrow=c(1,1))
}

# Return lists of plots for genes and cells
# For now works if nb.pcaAxis == 3
PCAplots <- function(PCAADE4, cellcol, size = 1, transparency = 0.6){
  require(ade4)
  require(adegraphics)
  stopifnot(PCAADE4$nf == 3)
  if(nrow(PCAADE4$li) != length(cellcol))
     return(paste0("Error: length(cellcol) [",length(cellcol),"] is not equal to the number of cells [",nrow(PCAADE4$li),"]"))
  
  genePlot <- function(absciss,ordinate){
    if((absciss == 3) && (ordinate == 2)) {
          # g32 seems more logical when displaying all 3 axes in the same plot
          # so we need to inverse coordinates
          g32df <- data.frame(-1*PCAADE4$co[,absciss], PCAADE4$co[,ordinate])
          rownames(g32df) <- rownames(PCAADE4$co)
          s.arrow(g32df,
                  plabels = list(box = list(draw = F), optim = T, cex = size, alpha = transparency),
                  main = paste0(absciss,",",ordinate),
                  xlab = paste0("comp ",absciss),
                  ylab = paste0("comp ",ordinate),
                  plot = F)
    }
    else {
          s.arrow(PCAADE4$co[,c(absciss,ordinate)],
                  plabels = list(box = list(draw = F), optim = T, cex = size, alpha = transparency),
                  main = paste0(absciss,",",ordinate),
                  xlab = paste0("comp ",absciss),
                  ylab = paste0("comp ",ordinate),
                  plot = F)
    }
  }
  
  cellPlot <- function(absciss,ordinate){
    if((absciss == 3) && (ordinate == 2)) {
          # g32 seems more logical when displaying all 3 axes in the same plot
          # so we need to inverse coordinates
          h32df <- data.frame(-1*PCAADE4$li[,absciss], PCAADE4$li[,ordinate])
          rownames(h32df) <- rownames(PCAADE4$li)
          s.label(h32df,
                  plabels = list(box = list(draw = F), optim = F, cex = size, alpha = transparency, col = cellcol),
                  ppoints = list(col = cellcol, cex = size),
                  main = paste0(absciss,",",ordinate),
                  xlab = paste0("comp ",absciss),
                  ylab = paste0("comp ",ordinate),
                  plot = F)
    }
    else {
      s.label(PCAADE4$li[,c(absciss,ordinate)], 
              plabels = list(box = list(draw = F), optim = F, cex = size, alpha = transparency, col = cellcol),
              ppoints = list(col = cellcol, cex = size),
              main = paste0(absciss,",",ordinate),
              xlab = paste0("comp ",absciss),
              ylab = paste0("comp ",ordinate),
              plot = F)
    }
  }

  return(list(
    genes = list(ax12 = genePlot(1,2), ax32 = genePlot(3,2), ax13 = genePlot(1,3), ax23 = genePlot(2,3)),
    cells = list(ax12 = cellPlot(1,2), ax32 = cellPlot(3,2), ax13 = cellPlot(1,3), ax23 = cellPlot(2,3))
  ))
}
```

```{r genes-pca-list-barplot, dev=c('png','svg')}
# Full list of genes ordered by components
genes.co.comp1 <- pcaCompGenesList(genes.pca$co, 1)
genes.co.comp2 <- pcaCompGenesList(genes.pca$co, 2)
genes.co.comp3 <- pcaCompGenesList(genes.pca$co, 3)

# How many genes to display ?
nb.dispGenes <- 25

# Listing the extremities
genes.co.comp1 %>% head(nb.dispGenes) 
genes.co.comp1 %>% tail(nb.dispGenes)
genes.co.comp2 %>% head(nb.dispGenes) 
genes.co.comp2 %>% tail(nb.dispGenes)
genes.co.comp3 %>% head(nb.dispGenes) 
genes.co.comp3 %>% tail(nb.dispGenes)

# Head and Tail Barplots (HTB)
HTB(genes.co.comp1, 1, nb.dispGenes)
HTB(genes.co.comp2, 2, nb.dispGenes)
HTB(genes.co.comp3, 3, nb.dispGenes)
```

```{r genes-pca-lico, dev=c('png','svg')}
# Clusters colored according to the dendrogram
# =========================================================
# /!\ step to be automatised /!\ 
#
# but for now needs manual calibration
# 1 - Display 'genes.dend.clusters'
# 2 - Please match the cluster number and
#     the position of the color in 'colors.pca$color'
#     You can type 'cor.dend.gg' to display the dendrogram
# 3 - Check that you have length(colors.pca) == nb.clusters
# =========================================================

colors.pca <- data_frame("group" = 1:nb.clusters,
                         color = c("red", "darkgreen", "darkseagreen", "blue", "green", "darkorange3", "grey40", "darkorchid4", "pink3", "turquoise4", "black"))

# Assignment of a color for each cell
colors.pca.li <- sapply(genes.dend.clusters, function(x) colors.pca$color[x])

# Size and transparency for genes and cells plots
size <- 1
transparency <- 0.6

# Generating lists of graphs
genes.plot <- PCAplots(genes.pca, colors.pca.li, size, transparency)

# Display genes and cells
ADEgS(list(genes.plot$genes$ax12, genes.plot$genes$ax32, genes.plot$genes$ax13,
           genes.plot$cells$ax12, genes.plot$cells$ax32, genes.plot$cells$ax13),
      layout = c(2,3))
```

### Hints for the component biological interpretation

#### Nuclear enrichment ?

```{r nuclear-bash, engine="bash", eval=TRUE}
# NOTICE that geneSymbolFDRBestScoreNuclear.dat could be made once for all ...

bedtools intersect -a 2016.02.24.nuc.cyto.simon.bed.gz -b /osc-fs_home/scratch/gmtu/annotation/homo_sapiens/gencode-18/gencode.v18.annotation.genes.bed -s -loj | awk '{OFS="\t"}{print $1,$2,$3,$28,$5,$6,$7,$8}' | sort -k 4 | tee nuc.cyto.simon.annotated.bed | bedtools groupby -g 4 -c 5 -o max > listOfmaxValues.temp

join -a1 -e1 -1 1 -2 4  listOfmaxValues.temp nuc.cyto.simon.annotated.bed | awk '{OFS="\t"}{ if ($2==$6) print($1, $9) }' > geneSymbolFDRBestScoreNuclear.dat
```

```{r nuclear, dev=c('svg', 'png')}
library(gridExtra)
library(tidyr)

# nuclearFDR has 2 columns: geneName, FDR
nuclearFDR <- read.table(file = "geneSymbolFDRBestScoreNuclear.dat", header = F)
colnames(nuclearFDR) <- c("geneNames", "FDR")

# Checking for duplicated genes
if(length(nuclearFDR$geneNames[duplicated(nuclearFDR$geneNames)]) != 0) 
  nuclearFDR %<>% group_by(geneNames) %>% summarise(FDR = min(FDR))

## How many genes do we have in the reference ?
paste("##", nrow(nuclearFDR), "genes are referenced in geneSymbolFDRBestScoreNuclear.dat", sep = " ")
## How many genes are below the filter.nuclearFDR threshold ?
filter.nuclearFDR <- 0.05
paste("##", sum(nuclearFDR$FDR < filter.nuclearFDR), "genes are under the threshold (", filter.nuclearFDR, ")", sep = " ")

# Genes names uniformisation
genes.co.comp1$geneNames %<>% toupper()
genes.co.comp2$geneNames %<>% toupper()
genes.co.comp3$geneNames %<>% toupper()
nuclearFDR$geneNames %<>% toupper()

# Inner join the comp values and FDR values
genes.co.comp1.FDR <- left_join(genes.co.comp1, nuclearFDR)[,-6] %>% replace_na(list(FDR = 1))
genes.co.comp2.FDR <- left_join(genes.co.comp2, nuclearFDR)[,-6] %>% replace_na(list(FDR = 1))
genes.co.comp3.FDR <- left_join(genes.co.comp3, nuclearFDR)[,-6] %>% replace_na(list(FDR = 1))

# Adjusting the 'shape' argument (in figure '*' if not referenced)
genes.co.comp1.FDR$Referenced <- sapply(genes.co.comp1.FDR$FDR, function(X) ifelse(X==1, return(FALSE), return(TRUE)))
genes.co.comp2.FDR$Referenced <- sapply(genes.co.comp2.FDR$FDR, function(X) ifelse(X==1, return(FALSE), return(TRUE)))
genes.co.comp3.FDR$Referenced <- sapply(genes.co.comp3.FDR$FDR, function(X) ifelse(X==1, return(FALSE), return(TRUE)))

## How many genes did we lost during the left join ?
paste("##", round(((nrow(genes.co.comp1) - nrow(genes.co.comp1.FDR %>% filter(Referenced==TRUE)))*100)/nrow(genes.co.comp1), 2), "% of the genes were not found in geneSymbolFDRBestScoreNuclear.dat", sep = " ")

# Plotting the principal component against nuclearFDR values
nuclearFDR.plot.comp1 <- ggplot(genes.co.comp1.FDR) + geom_point(aes(x=Comp1, y=log(FDR), colour = FDR, shape = Referenced)) + scale_shape_manual(values=c(8, 20)) + scale_color_continuous(low = "red", high = "black") + theme_classic() + geom_hline(aes(yintercept=log(filter.nuclearFDR)), col = "red")
nuclearFDR.plot.comp2 <- ggplot(genes.co.comp2.FDR) + geom_point(aes(x=Comp2, y=log(FDR), colour = FDR, shape = Referenced)) + scale_shape_manual(values=c(8, 20)) + scale_color_continuous(low = "red", high = "black") + theme_classic() + geom_hline(aes(yintercept=log(filter.nuclearFDR)), col = "red")
nuclearFDR.plot.comp3 <- ggplot(genes.co.comp3.FDR) + geom_point(aes(x=Comp3, y=log(FDR), colour = FDR, shape = Referenced)) + scale_shape_manual(values=c(8, 20)) + scale_color_continuous(low = "red", high = "black") + theme_classic() + geom_hline(aes(yintercept=log(filter.nuclearFDR)), col = "red")

grid.arrange(nuclearFDR.plot.comp1, nuclearFDR.plot.comp2, nuclearFDR.plot.comp3)
```



### PCA on Libs

Gene counts and TSS discovery
-----------------------------

### Gene count by error code.

```{r gene-count, dev=c('svg', 'png'), fig.height=2.5}
dotsize <- 50
ggplot(libs, aes(x=Group, y=genes)) +
  stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean, geom="crossbar", color="gray") +
  geom_dotplot(aes(fill=Group), binaxis='y', binwidth=1, dotsize=dotsize, stackdir='center') +
  coord_flip() + facet_wrap(~Run)
```

### Gene count per transcript count.

```{r gene-counts-run-plot, dev=c('svg', 'png')}
with(libs, plotNameColor(genes, counts, Run, Well))
```

### Gene counts per C1 run.

```{r gene-counts-run-boxplot, dev=c('svg', 'png')}
#boxplot(data=subset(libs, Error == "0-No Error"), genes ~ Run, ylab="Number of genes detexted (aprox)", main="Comparison of gene detection by run.")
#t.test(data=subset(libs, Error == "0-No Error"), genes ~ Run)
```

Rarefaction (hanabi plot).
--------------------------

FIXME: dark orange !

### Rarefaction

```{r calculate-rarefactions}
# Subsampling sizes: one point for each cell's sample size, plus a few
# points for smaller values, to be able to plot smoothly.

subSampleSizes <- function(X)
  sort(unique(round(c( X
                   , max(X) / 2^(16:0)
                   , (max(X) / 16) * 16:1))))

sampleSizeCounts <- subSampleSizes(colSums(l1))

# Cachig the transpositions, just in case
# it matters for the performance.

t1 <- t(l1)
tg <- t(genes)

# Rarefy at each sampling point.  It takes time !
# In the resluting tables, the columns are a subsampling size, and
# the rows are a cell.

rar1 <- sapply(sampleSizeCounts, function(X) rarefy(t1, X))
rarg <- sapply(sampleSizeCounts, function(X) rarefy(tg, X))

samplesOK <- bed$library %>% factor %>% levels %>% sub('RunA',RunA,.) %>% sub('RunB',RunB,.) # somes samples will be missing if they had no reads.

sampleSizePairs <- subSampleSizes(libs[samplesOK, "properpairs"])

rarefyLong <- function(TABLE, N)
  tapply(TABLE$score, TABLE$library, rarefy, N)

rarU <- sapply(sampleSizePairs, function(N) rarefyLong(bed, N))
```

### TSS discovery

```{r hanabi-TSS, dev=c('svg', 'png')}
hanabiPlot(rar1, sampleSizeCounts, ylab='number of TSS detected', xlab='number of unique molecule counts', main=paste("TSS discovery for", LIBRARY), GROUP=libs$Group)

legend('topleft',legend=levels(libs$Group), col=1:length(levels(libs$Group)), pch=1)
```

### Gene discovery

```{r hanabi-gene, dev=c('svg', 'png')}
hanabiPlot(rarg, sampleSizeCounts, ylab='number of genes detected', xlab='number of unique molecule counts', main=paste("Gene discovery for", LIBRARY), GROUP=libs$Group)

legend('topleft',legend=levels(libs$Group), col=1:length(levels(libs$Group)), pch=1)
```

### Molecule discovery (with raw reads)

````{r hanabi-UMI, dev=c('svg', 'png')}
hanabiPlot(rarU, sampleSizePairs, ylab='number of molecules detected', xlab='number of properly mapped reads', main=paste("Transcript discovery for", LIBRARY), GROUP=libs$Group)

legend('topleft',legend=levels(libs$Group), col=1:length(levels(libs$Group)), pch=1)
```

### Comparison between the runs

(only "No Error" cells)

```{r hanabi-runs, dev=c('svg', 'png')}
#hanabiPlot(rarg[libs$Error=="0-No Error",], sampleSizeCounts, ylab='number of genes detected', xlab='number of unique molecule counts', main=paste("Gene discovery for", LIBRARY), GROUP=libs[libs$Error=="0-No Error", "Run"])

#legend('topleft',legend=levels(libs[libs$Error=="0-No Error", "Run"]), col=1:length(levels(libs[libs$Error=="0-No Error", "Run"])), pch=1)
```


Data load on Zenbu.
===================

FIXME: will do later
FIXME: make idempotent

Accessory functions
-------------------

Uploading to Zenbu collaboration `r ZENBU_COLLAB`.

Ad-hoc wrapper to the shell command `zenbu_upload`

```{r define_zenbuUpload}
zenbuUpload <- function ( ...
                        , URL="http://fantom.gsc.riken.jp/zenbu"
                        , verbose=FALSE
                        , echo=FALSE
                        , stdout=TRUE) {
  zenbu <- 'zenbu_upload'
  url <- c('-url', URL)
  args <- sapply(c(url, ...), shQuote)
  if (verbose == TRUE) print(paste(c(zenbu, args), collapse=' '))
  if (echo    == FALSE) {
      system2(zenbu, args, stdout=stdout)
  } else {
      system2('echo', c(zenbu, args), stdout=stdout)
  }
}
```

To transform a file name in a sample identifier.

```{r define_bedToSample}
bedToSample <- function(BED)
  BED %>%
    sub("RunA", RunA, .) %>%
    sub("RunB", RunB, .) %>%
    sub(".bed", "", .)
```

To produce a string of keywords that will uniquely identify a sample.

TODO: move keywords to the top.

```{r define_sampleDescription}
sampleDescription <- function(BED)
  paste( MOIRAI_FRAGS
       , bedToSample(BED)
       , "what kind of data" # For innstance "CAGEscan_fragments"
       , "a keyword for easy retrieval" # For instance "KnitrUpload"
         # add more keywords as needed
       )
```

To upload CAGEscan fragments, only if they have not yet been uploaded.

```{r define_safeZupload}
safeZupload <- function (BED) {
  # Warning: the "notFound" function ignores queued uploads...
  notFound <- function(BED)
    zenbuUpload( "-list", "-filter", sampleDescription(BED)) %>%
      tail(1) %>%
      grepl ("0 uploads --- 0 featuresources --- 0 experiments --- \\[0 total sources\\]", .)
  if(notFound(BED))
    zenbuUpload( "-file",        paste(MOIRAI_FRAGS, BED, sep="/")
               , "-name",        BED  %>% sub(".bed", "", .)
               , "-assembly",    ASSEMBLY
               , "-desc",        sampleDescription(BED)
               , "-collab_uuid", ZENBU_COLLAB
               , "-singletag_exp"
               , stdout="")
}
```

Functions to add metadata tags.

```{r tag-in-zenbu}
zenbuTag <- function (filter, key, value, mode='add', ...) {
  args <- c('-mdedit', filter, mode, key, value)
  zenbuUpload (args, ...)
}

tagError <- function(BED)
  zenbuTag( sampleDescription(BED)
          , 'cellomics'
          , libs[bedToSample(BED), "Error"] %>% as.character)

tagMeta <- function(BED, TAG)
  zenbuTag( sampleDescription(BED)
          , TAG
          , libs[bedToSample(BED), TAG] %>% as.character)

tagComment <- function (Sample, comment, ...) {
  filter <- paste(MOIRAI_FRAGS, Sample, "C1_CAGEscan_fragments", "KnitrUpload")
  zenbuTag(filter, 'cellomics_comment', comment, ...)
}

#apply(libs[,c('Well', 'Error')],   1, function(X) tagError  (X[1], X[2]))
#apply(libs[,c('Well', 'Comment')], 1, function(X) tagComment(X[1], X[2]))

#keywords need to be stringent: "D12"" matches BED12 !!!
```

### Zenbu uploads and tagging

```{r upload-and-tag}
samplesToUpload <- subset(libs, properpairs > 0, "samplename", drop=T) %>%
  sub(RunA, "RunA", .) %>%
  sub(RunB, "RunB", .) %>%
  sub("$", ".bed", .)

sapply(samplesToUpload, safeZupload)
sapply(samplesToUpload, tagError)
sapply(samplesToUpload, tagMeta, TAG="Group")
sapply(samplesToUpload, tagMeta, TAG="Run")
sapply(samplesToUpload, tagMeta, TAG="row")
sapply(samplesToUpload, tagMeta, TAG="column")
```
