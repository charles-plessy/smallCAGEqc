% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mapStats.R
\name{mapStats}
\alias{mapStats}
\title{mapStats}
\usage{
mapStats(libs, scope = c("all", "annotation", "counts", "mapped", "qc",
  "steps"), group = "default")
}
\arguments{
\item{libs}{A data frame with columns named \code{promoter}, \code{exon}, \code{intron}
\code{mapped}, \code{extracted}, \code{rdna}, and \code{tagdust}.}

\item{scope}{The value on which to normalise. \dQuote{all} and \dQuote{qc}
normalise on the number of extracted tags, \dQuote{annotation} on the
number of aligned tags, \dQuote{mapped} on the number of aligned tags
and \dQuote{counts} on the transcript counts.}

\item{group}{A vector of factors defining groups in the data.  By default,
the \dQuote{group} column of the \dQuote{libs} table.}
}
\value{
Returns a data frame with mean and standard deviation of normalised mapping statistics,
plus absolute positions for the error bars.  The first column, \code{group}, is
a vector of factors sorted with the \code{gtools::mixedorder} function.
}
\description{
Process mapping statistics
}
\details{
Using a data frame containing mapping statistics in counts, transform the data in
percentages that can be used for stacked barplots.

See http://stackoverflow.com/questions/10417003/stacked-barplot-with-errorbars-using-ggplot2 about stacked barplot.

The \dQuote{mapped} and \dQuote{counts} scopes assume that transcript counts are available.



The following categories describe the total remaining pairs after each
step of the processing.

\describe{
  \item{total}{The total number of pairs before tag extraction.  In some
  cases this number is not available per sample, for example when
  demultiplexing and tag extraction are performed at the same stage.}
  \item{extracted}{The number of pairs where the linkers and unique
  molecular identifier (if present) were succesfully extracted.}
  \item{cleaned}{The number of pairs remaining after filtering out spike,
  rRNA, low-complexity, primer artefact and other unwanted sequences.}
  \item{mapped}{The number of pairs with at least one successful
  alignment.}
  \item{counts}{The number of unique molecules counted after alignment.}
}

The following categories describe the number of pairs removed at each
step of the processing.

\describe{
  \item{unextracted}{The total number of pairs where a tag could not
  be extracted.}
  \item{spikes, rRNA}{The number of pairs removed because they matched
  spikes or rRNA reference sequences, respectively.}
  \item{tagdust}{The number of pairs removed because of low-complexity
  or similarity to primer artefacts.}
  \item{unmapped}{The number of non-mapped pairs.}
  \item{non-proper}{The number of non-properly mapped pairs.}
  \item{duplicates}{The number of pairs that do not add a molecule count.}
}

Here is a description of each scope.

\describe{
  \item{all}{Reads are categorised by extraction step and genome
  annotation.}
  \item{steps}{Reads are catetorised by the extraction steps described
  above (Total, Extracted, Cleaned, Mapped and Counts).}
  \item{qc}{"counts", "properpairs", "mapped", "unmapped", "spikes", "rdna", "tagdust"}
  \item{mapped}{"promoter","exon","intron","intergenic", "duplicates"}
  \item{counts}{The unique molecule counts are grouped in
  annotation categories ("promoter", "exon", "intron" and "intergenic")}
  \item{annotation}{Same as \sQuote{all} except that normalisation is
  relative to the number of mapped reads.}
}
}
\examples{
libs <- read.csv( system.file("extdata", "libs.csv", package = "smallCAGEqc")
                , row.names = 1)
mapStats(libs, "qc", libs$Error)

}
\seealso{
\code{\link{loadLogs}}, \code{\link{loadMoiraiStats}}

Other smallCAGEqc annotation functions: \code{\link{hannot}},
  \code{\link{hierarchAnnot}}, \code{\link{plotAnnot}}
}

